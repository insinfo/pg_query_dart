// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

class PgQueryBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  PgQueryBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  PgQueryBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Função que normaliza comandos utilitários de uma consulta SQL.
  ///
  /// Similar à `pg_query_normalize`, mas voltada para comandos utilitários
  /// específicos de PostgreSQL.
  PgQueryNormalizeResult pg_query_normalize(
    ffi.Pointer<ffi.Char> input,
  ) {
    return _pg_query_normalize(
      input,
    );
  }

  late final _pg_query_normalizePtr = _lookup<
      ffi.NativeFunction<
          PgQueryNormalizeResult Function(
              ffi.Pointer<ffi.Char>)>>('pg_query_normalize');
  late final _pg_query_normalize = _pg_query_normalizePtr
      .asFunction<PgQueryNormalizeResult Function(ffi.Pointer<ffi.Char>)>();

  /// Função que normaliza comandos utilitários de uma consulta SQL.
  ///
  /// Similar à `pg_query_normalize`, mas voltada para comandos utilitários
  /// específicos de PostgreSQL.
  PgQueryNormalizeResult pg_query_normalize_utility(
    ffi.Pointer<ffi.Char> input,
  ) {
    return _pg_query_normalize_utility(
      input,
    );
  }

  late final _pg_query_normalize_utilityPtr = _lookup<
      ffi.NativeFunction<
          PgQueryNormalizeResult Function(
              ffi.Pointer<ffi.Char>)>>('pg_query_normalize_utility');
  late final _pg_query_normalize_utility = _pg_query_normalize_utilityPtr
      .asFunction<PgQueryNormalizeResult Function(ffi.Pointer<ffi.Char>)>();

  /// Função que realiza a varredura (scan) de uma consulta SQL.
  ///
  /// Essa função analisa a string SQL fornecida e retorna um objeto `PgQueryScanResult`,
  /// que contém os tokens resultantes do processo de varredura e possíveis erros.
  PgQueryScanResult pg_query_scan(
    ffi.Pointer<ffi.Char> input,
  ) {
    return _pg_query_scan(
      input,
    );
  }

  late final _pg_query_scanPtr = _lookup<
      ffi.NativeFunction<
          PgQueryScanResult Function(ffi.Pointer<ffi.Char>)>>('pg_query_scan');
  late final _pg_query_scan = _pg_query_scanPtr
      .asFunction<PgQueryScanResult Function(ffi.Pointer<ffi.Char>)>();

  /// Função que realiza o parsing (análise sintática) de uma consulta SQL.
  ///
  /// A função recebe uma string SQL e retorna um objeto `PgQueryParseResult`,
  /// que contém a árvore de análise sintática e informações sobre possíveis erros.
  PgQueryParseResult pg_query_parse(
    ffi.Pointer<ffi.Char> input,
  ) {
    return _pg_query_parse(
      input,
    );
  }

  late final _pg_query_parsePtr = _lookup<
          ffi
          .NativeFunction<PgQueryParseResult Function(ffi.Pointer<ffi.Char>)>>(
      'pg_query_parse');
  late final _pg_query_parse = _pg_query_parsePtr
      .asFunction<PgQueryParseResult Function(ffi.Pointer<ffi.Char>)>();

  /// Função que realiza o parsing com opções adicionais.
  ///
  /// Recebe uma string contendo a consulta SQL e um conjunto de opções que
  /// modificam o comportamento do parser, retornando o resultado da análise.
  PgQueryParseResult pg_query_parse_opts(
    ffi.Pointer<ffi.Char> input,
    int parser_options,
  ) {
    return _pg_query_parse_opts(
      input,
      parser_options,
    );
  }

  late final _pg_query_parse_optsPtr = _lookup<
      ffi.NativeFunction<
          PgQueryParseResult Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('pg_query_parse_opts');
  late final _pg_query_parse_opts = _pg_query_parse_optsPtr
      .asFunction<PgQueryParseResult Function(ffi.Pointer<ffi.Char>, int)>();

  /// Função que faz o parsing de uma consulta em formato protobuf.
  ///
  /// Retorna um `PgQueryProtobufParseResult` com a árvore sintática em formato protobuf.
  PgQueryProtobufParseResult pg_query_parse_protobuf(
    ffi.Pointer<ffi.Char> input,
  ) {
    return _pg_query_parse_protobuf(
      input,
    );
  }

  late final _pg_query_parse_protobufPtr = _lookup<
      ffi.NativeFunction<
          PgQueryProtobufParseResult Function(
              ffi.Pointer<ffi.Char>)>>('pg_query_parse_protobuf');
  late final _pg_query_parse_protobuf = _pg_query_parse_protobufPtr
      .asFunction<PgQueryProtobufParseResult Function(ffi.Pointer<ffi.Char>)>();

  PgQueryProtobufParseResult pg_query_parse_protobuf_opts(
    ffi.Pointer<ffi.Char> input,
    int parser_options,
  ) {
    return _pg_query_parse_protobuf_opts(
      input,
      parser_options,
    );
  }

  late final _pg_query_parse_protobuf_optsPtr = _lookup<
      ffi.NativeFunction<
          PgQueryProtobufParseResult Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('pg_query_parse_protobuf_opts');
  late final _pg_query_parse_protobuf_opts =
      _pg_query_parse_protobuf_optsPtr.asFunction<
          PgQueryProtobufParseResult Function(ffi.Pointer<ffi.Char>, int)>();

  PgQueryPlpgsqlParseResult pg_query_parse_plpgsql(
    ffi.Pointer<ffi.Char> input,
  ) {
    return _pg_query_parse_plpgsql(
      input,
    );
  }

  late final _pg_query_parse_plpgsqlPtr = _lookup<
      ffi.NativeFunction<
          PgQueryPlpgsqlParseResult Function(
              ffi.Pointer<ffi.Char>)>>('pg_query_parse_plpgsql');
  late final _pg_query_parse_plpgsql = _pg_query_parse_plpgsqlPtr
      .asFunction<PgQueryPlpgsqlParseResult Function(ffi.Pointer<ffi.Char>)>();

  /// Função que gera uma impressão digital (fingerprint) de uma consulta SQL.
  ///
  /// A impressão digital é uma representação única de uma consulta SQL, que
  /// pode ser usada para comparar consultas de forma eficiente.
  PgQueryFingerprintResult pg_query_fingerprint(
    ffi.Pointer<ffi.Char> input,
  ) {
    return _pg_query_fingerprint(
      input,
    );
  }

  late final _pg_query_fingerprintPtr = _lookup<
      ffi.NativeFunction<
          PgQueryFingerprintResult Function(
              ffi.Pointer<ffi.Char>)>>('pg_query_fingerprint');
  late final _pg_query_fingerprint = _pg_query_fingerprintPtr
      .asFunction<PgQueryFingerprintResult Function(ffi.Pointer<ffi.Char>)>();

  /// Função que gera uma impressão digital de uma consulta SQL com opções adicionais.
  ///
  /// Funciona de forma semelhante à `pg_query_fingerprint`, mas permite que sejam
  /// passadas opções adicionais para o parser.
  PgQueryFingerprintResult pg_query_fingerprint_opts(
    ffi.Pointer<ffi.Char> input,
    int parser_options,
  ) {
    return _pg_query_fingerprint_opts(
      input,
      parser_options,
    );
  }

  late final _pg_query_fingerprint_optsPtr = _lookup<
      ffi.NativeFunction<
          PgQueryFingerprintResult Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('pg_query_fingerprint_opts');
  late final _pg_query_fingerprint_opts =
      _pg_query_fingerprint_optsPtr.asFunction<
          PgQueryFingerprintResult Function(ffi.Pointer<ffi.Char>, int)>();

// Use pg_query_split_with_scanner when you need to split statements that may
// contain parse errors, otherwise pg_query_split_with_parser is recommended
// for improved accuracy due the parser adding additional token handling.
//
// Note that we try to support special cases like comments, strings containing
// ";" on both, as well as oddities like "CREATE RULE .. (SELECT 1; SELECT 2);"
// which is treated as as single statement.
  /// Função que separa uma consulta SQL em múltiplas instruções usando o scanner.
  ///
  /// Essa função processa a consulta SQL e separa em múltiplas instruções,
  /// retornando um `PgQuerySplitResult`.
  PgQuerySplitResult pg_query_split_with_scanner(
    ffi.Pointer<ffi.Char> input,
  ) {
    return _pg_query_split_with_scanner(
      input,
    );
  }

  late final _pg_query_split_with_scannerPtr = _lookup<
          ffi
          .NativeFunction<PgQuerySplitResult Function(ffi.Pointer<ffi.Char>)>>(
      'pg_query_split_with_scanner');
  late final _pg_query_split_with_scanner = _pg_query_split_with_scannerPtr
      .asFunction<PgQuerySplitResult Function(ffi.Pointer<ffi.Char>)>();

  /// Função que separa uma consulta SQL em múltiplas instruções usando o parser.
  ///
  /// Processa a consulta SQL e a divide em várias instruções, retornando um `PgQuerySplitResult`.
  PgQuerySplitResult pg_query_split_with_parser(
    ffi.Pointer<ffi.Char> input,
  ) {
    return _pg_query_split_with_parser(
      input,
    );
  }

  late final _pg_query_split_with_parserPtr = _lookup<
          ffi
          .NativeFunction<PgQuerySplitResult Function(ffi.Pointer<ffi.Char>)>>(
      'pg_query_split_with_parser');
  late final _pg_query_split_with_parser = _pg_query_split_with_parserPtr
      .asFunction<PgQuerySplitResult Function(ffi.Pointer<ffi.Char>)>();

  /// Função que faz o parsing de uma consulta em formato protobuf.
  ///
  /// Retorna um `PgQueryProtobufParseResult` com a árvore sintática em formato protobuf.
  PgQueryDeparseResult pg_query_deparse_protobuf(
    PgQueryProtobuf parse_tree,
  ) {
    return _pg_query_deparse_protobuf(
      parse_tree,
    );
  }

  late final _pg_query_deparse_protobufPtr = _lookup<
          ffi.NativeFunction<PgQueryDeparseResult Function(PgQueryProtobuf)>>(
      'pg_query_deparse_protobuf');
  late final _pg_query_deparse_protobuf = _pg_query_deparse_protobufPtr
      .asFunction<PgQueryDeparseResult Function(PgQueryProtobuf)>();

  /// Libera a memória alocada para o resultado da normalização.
  ///
  /// Essa função deve ser chamada para liberar a memória ocupada por um objeto `PgQueryNormalizeResult`
  /// quando ele não for mais necessário.
  void pg_query_free_normalize_result(
    PgQueryNormalizeResult result,
  ) {
    return _pg_query_free_normalize_result(
      result,
    );
  }

  late final _pg_query_free_normalize_resultPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(PgQueryNormalizeResult)>>(
          'pg_query_free_normalize_result');
  late final _pg_query_free_normalize_result =
      _pg_query_free_normalize_resultPtr
          .asFunction<void Function(PgQueryNormalizeResult)>();

  void pg_query_free_scan_result(
    PgQueryScanResult result,
  ) {
    return _pg_query_free_scan_result(
      result,
    );
  }

  late final _pg_query_free_scan_resultPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(PgQueryScanResult)>>(
          'pg_query_free_scan_result');
  late final _pg_query_free_scan_result = _pg_query_free_scan_resultPtr
      .asFunction<void Function(PgQueryScanResult)>();
  // Funções para liberar outros tipos de resultados, como pg_query_free_scan_result,
  void pg_query_free_parse_result(
    PgQueryParseResult result,
  ) {
    return _pg_query_free_parse_result(
      result,
    );
  }

  late final _pg_query_free_parse_resultPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(PgQueryParseResult)>>(
          'pg_query_free_parse_result');
  late final _pg_query_free_parse_result = _pg_query_free_parse_resultPtr
      .asFunction<void Function(PgQueryParseResult)>();

  void pg_query_free_split_result(
    PgQuerySplitResult result,
  ) {
    return _pg_query_free_split_result(
      result,
    );
  }

  late final _pg_query_free_split_resultPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(PgQuerySplitResult)>>(
          'pg_query_free_split_result');
  late final _pg_query_free_split_result = _pg_query_free_split_resultPtr
      .asFunction<void Function(PgQuerySplitResult)>();

  void pg_query_free_deparse_result(
    PgQueryDeparseResult result,
  ) {
    return _pg_query_free_deparse_result(
      result,
    );
  }

  late final _pg_query_free_deparse_resultPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(PgQueryDeparseResult)>>(
          'pg_query_free_deparse_result');
  late final _pg_query_free_deparse_result = _pg_query_free_deparse_resultPtr
      .asFunction<void Function(PgQueryDeparseResult)>();

  void pg_query_free_protobuf_parse_result(
    PgQueryProtobufParseResult result,
  ) {
    return _pg_query_free_protobuf_parse_result(
      result,
    );
  }

  late final _pg_query_free_protobuf_parse_resultPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(PgQueryProtobufParseResult)>>(
      'pg_query_free_protobuf_parse_result');
  late final _pg_query_free_protobuf_parse_result =
      _pg_query_free_protobuf_parse_resultPtr
          .asFunction<void Function(PgQueryProtobufParseResult)>();

  void pg_query_free_plpgsql_parse_result(
    PgQueryPlpgsqlParseResult result,
  ) {
    return _pg_query_free_plpgsql_parse_result(
      result,
    );
  }

  late final _pg_query_free_plpgsql_parse_resultPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(PgQueryPlpgsqlParseResult)>>(
          'pg_query_free_plpgsql_parse_result');
  late final _pg_query_free_plpgsql_parse_result =
      _pg_query_free_plpgsql_parse_resultPtr
          .asFunction<void Function(PgQueryPlpgsqlParseResult)>();

  void pg_query_free_fingerprint_result(
    PgQueryFingerprintResult result,
  ) {
    return _pg_query_free_fingerprint_result(
      result,
    );
  }

  late final _pg_query_free_fingerprint_resultPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(PgQueryFingerprintResult)>>(
          'pg_query_free_fingerprint_result');
  late final _pg_query_free_fingerprint_result =
      _pg_query_free_fingerprint_resultPtr
          .asFunction<void Function(PgQueryFingerprintResult)>();

  /// Finaliza a biblioteca PgQuery e libera todos os recursos alocados.
  ///
  /// Deve ser chamada quando a biblioteca não for mais necessária para garantir
  /// que todos os recursos são liberados corretamente.
  ///  Optional, cleans up the top-level memory context (automatically done for threads that exit)
  void pg_query_exit() {
    return _pg_query_exit();
  }

  late final _pg_query_exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('pg_query_exit');
  late final _pg_query_exit = _pg_query_exitPtr.asFunction<void Function()>();

  /// Inicializa a biblioteca PgQuery para uso.
  ///
  /// Deve ser chamada antes de utilizar qualquer outra função para garantir que a
  /// biblioteca está configurada corretamente.
  ///  Deprecated APIs below
  ///  Deprecated as of 9.5-1.4.1, this is now run automatically as needed
  void pg_query_init() {
    return _pg_query_init();
  }

  late final _pg_query_initPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('pg_query_init');
  late final _pg_query_init = _pg_query_initPtr.asFunction<void Function()>();
}

final class PgQueryError extends ffi.Struct {
  /// exception message
  external ffi.Pointer<ffi.Char> message;

  /// source function of exception (e.g. SearchSysCache)
  external ffi.Pointer<ffi.Char> funcname;

  /// source of exception (e.g. parse.l)
  external ffi.Pointer<ffi.Char> filename;

  /// source of exception (e.g. 104)
  @ffi.Int()
  external int lineno;

  /// char in query at which exception occurred
  @ffi.Int()
  external int cursorpos;

  /// additional context (optional, can be NULL)
  external ffi.Pointer<ffi.Char> context;
}

final class PgQueryProtobuf extends ffi.Struct {
  @ffi.Size()
  external int len;

  external ffi.Pointer<ffi.Char> data;
}

final class PgQueryScanResult extends ffi.Struct {
  external PgQueryProtobuf pbuf;

  external ffi.Pointer<ffi.Char> stderr_buffer;

  external ffi.Pointer<PgQueryError> error;
}

final class PgQueryParseResult extends ffi.Struct {
  external ffi.Pointer<ffi.Char> parse_tree;

  external ffi.Pointer<ffi.Char> stderr_buffer;

  external ffi.Pointer<PgQueryError> error;
}

final class PgQueryProtobufParseResult extends ffi.Struct {
  external PgQueryProtobuf parse_tree;

  external ffi.Pointer<ffi.Char> stderr_buffer;

  external ffi.Pointer<PgQueryError> error;
}

final class PgQuerySplitStmt extends ffi.Struct {
  @ffi.Int()
  external int stmt_location;

  @ffi.Int()
  external int stmt_len;
}

final class PgQuerySplitResult extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<PgQuerySplitStmt>> stmts;

  @ffi.Int()
  external int n_stmts;

  external ffi.Pointer<ffi.Char> stderr_buffer;

  external ffi.Pointer<PgQueryError> error;
}

final class PgQueryDeparseResult extends ffi.Struct {
  external ffi.Pointer<ffi.Char> query;

  external ffi.Pointer<PgQueryError> error;
}

final class PgQueryPlpgsqlParseResult extends ffi.Struct {
  external ffi.Pointer<ffi.Char> plpgsql_funcs;

  external ffi.Pointer<PgQueryError> error;
}

final class PgQueryFingerprintResult extends ffi.Struct {
  @ffi.Uint64()
  external int fingerprint;

  external ffi.Pointer<ffi.Char> fingerprint_str;

  external ffi.Pointer<ffi.Char> stderr_buffer;

  external ffi.Pointer<PgQueryError> error;
}

final class PgQueryNormalizeResult extends ffi.Struct {
  external ffi.Pointer<ffi.Char> normalized_query;

  external ffi.Pointer<PgQueryError> error;
}

/// Postgres parser options (parse mode and GUCs that affect parsing)
abstract class PgQueryParseMode {
  static const int PG_QUERY_PARSE_DEFAULT = 0;
  static const int PG_QUERY_PARSE_TYPE_NAME = 1;
  static const int PG_QUERY_PARSE_PLPGSQL_EXPR = 2;
  static const int PG_QUERY_PARSE_PLPGSQL_ASSIGN1 = 3;
  static const int PG_QUERY_PARSE_PLPGSQL_ASSIGN2 = 4;
  static const int PG_QUERY_PARSE_PLPGSQL_ASSIGN3 = 5;
}

/// We technically only need 3 bits to store parse mode, but
/// having 4 bits avoids API breaks if another one gets added.
const int PG_QUERY_PARSE_MODE_BITS = 4;
const int PG_QUERY_PARSE_MODE_BITMASK = 15;
/// backslash_quote = off (default is safe_encoding, which is effectively on)
const int PG_QUERY_DISABLE_BACKSLASH_QUOTE = 16;
/// standard_conforming_strings = off (default is on)
const int PG_QUERY_DISABLE_STANDARD_CONFORMING_STRINGS = 32;
/// escape_string_warning = off (default is on)
const int PG_QUERY_DISABLE_ESCAPE_STRING_WARNING = 64;
// Postgres version information
const String PG_MAJORVERSION = '16';
const String PG_VERSION = '16.1';
const int PG_VERSION_NUM = 160001;
